<!--
Copyright 2018 Google LLC

Use of this source code is governed by an MIT-style
license that can be found in the LICENSE file or at
https://opensource.org/licenses/MIT.
=============================================================================
-->

<!doctype html>
<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
  <script src="../dist/tensorflow.debug.js"></script>
  <script src="../dist/demo/mnist_transfer_cnn.keras.model.js"></script>
  <script src="../dist/demo/mnist_transfer_cnn.keras.weights.js"></script>
  <script src="../dist/demo/mnist_transfer_cnn.gte5.train.js"></script>
  <script src="../dist/demo/mnist_transfer_cnn.gte5.test.js"></script>
</head>

<style>
  .input-div {
    padding: 5px;
    font-family: monospace;
  }
  .predict-div {
    padding: 5px;
    padding-top: 20px;
  }
  .predict-table {
    font-family: monospace;
    table-layout: fixed;
    border-collapse: collapse;
    border: 1px solid black;
  }
  td {
    padding-left: 5px;
    padding-right: 5px;
    padding-bottom: 5px;
  }
  #predict-header {
    font-weight: bold;
  }
  .output-div {
    padding: 5px;
    padding-top: 20px;
    font-family: monospace;
    font-weight: bold;
  }
  .retrain-div {
    padding: 5px;
    padding-top: 20px;
    padding-bottom: 30px;
    font-family: monospace;
    font-weight: bold;
  }
  #image-input {
    font-family: monospace;
    position: relative;
    width: 100%;
  }
  body {
    margin-top: 25px;
    margin-left: 25px;
  }
</style>

<body>
  <h1>TensorFlow.js Layers: MNIST CNN Transfer Learning Demo</h1>

  <div class="retrain-div">
      <button class="btn btn-primary" id="retrain"><span>Retrain</span></button>
      <input class="input" id="epochs" value="5" style="width:3em"></input>
      <span>epochs</span>
      <progress id="trainProg" value="0" max="100" style="width:35%"></progress>
      <span id="retrainStatus">Standing by.</span>
  </div>

  <select id="test-image-select" class="form-control">
    <option class="head">Select test example</option>
    <option value="5_1">5_1</option>
    <option value="5_2">5_2</option>
    <option value="5_3">5_3</option>
    <option value="5_4">5_4</option>
    <option value="5_5">5_5</option>
    <option value="5_6">5_6</option>
    <option value="5_7">5_7</option>
    <option value="5_8">5_8</option>
    <option value="5_9">5_9</option>
    <option value="5_10">5_10</option>
    <option value="6_1">6_1</option>
    <option value="6_2">6_2</option>
    <option value="6_3">6_3</option>
    <option value="6_4">6_4</option>
    <option value="6_5">6_5</option>
    <option value="6_6">6_6</option>
    <option value="6_7">6_7</option>
    <option value="6_8">6_8</option>
    <option value="6_9">6_9</option>
    <option value="6_10">6_10</option>
    <option value="7_1">7_1</option>
    <option value="7_2">7_2</option>
    <option value="7_3">7_3</option>
    <option value="7_4">7_4</option>
    <option value="7_5">7_5</option>
    <option value="7_6">7_6</option>
    <option value="7_7">7_7</option>
    <option value="7_8">7_8</option>
    <option value="7_9">7_9</option>
    <option value="7_10">7_10</option>
    <option value="8_1">8_1</option>
    <option value="8_2">8_2</option>
    <option value="8_3">8_3</option>
    <option value="8_4">8_4</option>
    <option value="8_5">8_5</option>
    <option value="8_6">8_6</option>
    <option value="8_7">8_7</option>
    <option value="8_8">8_8</option>
    <option value="8_9">8_9</option>
    <option value="8_10">8_10</option>
    <option value="9_1">9_1</option>
    <option value="9_2">9_2</option>
    <option value="9_3">9_3</option>
    <option value="9_4">9_4</option>
    <option value="9_5">9_5</option>
    <option value="9_6">9_6</option>
    <option value="9_7">9_7</option>
    <option value="9_8">9_8</option>
    <option value="9_9">9_9</option>
    <option value="9_10">9_10</option>
  </select>

  <textarea id="image-input" rows="28"></textarea>

  <div class='predict-div'>
    <table class='predict-table'>
      <tr id='predict-header'>
      </tr>
      <tr id='predict-values'>
        </tr>
    </table>
  </div>

  <div class='output-div'>
    <span class="output-label">Output class: </span>
    <input id="winner" readonly="true"></input>
  </div>

  <script>
    function deserializeModel() {
      console.log('Deserialization model architecture.');
      const model = tfjs_layers.modelFromJSON(mnistModelJSON);

      console.log('Loading model weights.');
      model.loadWeights(mnistWeightsJSON);
      return model;
    }

    const model = deserializeModel();

    // Some hard-coded MNIST image examples for interactive testing.
    const testExamples = {}
    const digitCounts = {5: 0, 6: 0, 7: 0, 8: 0, 9: 0};
    const examplesPerDigit = 10;
    // Enter one example of each of 5, 6, 7, 8, 9 in `testExamples`.
    for (let i = gte5TestData.length - 1; i >= 0; --i) {
      const datum = gte5TestData[i];
      const digit = datum.y + 5;
      if (digitCounts[digit] >= examplesPerDigit) {
        continue;
      }
      digitCounts[digit]++;
      const key = String(digit) + '_' + String(digitCounts[digit]);
      testExamples[key] = [];
      for (const row of datum.x) {
        testExamples[key] = testExamples[key].concat(row);
      }
      if (_.keys(testExamples).length >= 5 * examplesPerDigit) {
        break;
      }
    }

    const imageSize = model.layers[0].batchInputShape[1];

    const imageInput = $('#image-input');
    const testImageSelect = $('#test-image-select');

    // Convert an image vector (length 784) representing an MNIST image into
    // human-friendly a text representation.
    //
    // Args:
    //   imageVector: An Array of Numbers of length `imageSize * imageSize`.
    //
    // Returns:
    //   A String representing the image.
    function imageVectorToText(imageVector) {
      if (imageVector.length !== imageSize * imageSize) {
        throw new Error('Incorrect length of image vector (expected ' +
                        imageSize * imageSize + '; got ' +
                        imageVector.length + ')');
      }
      let text = '';
      for (let i = 0; i < imageSize * imageSize; ++i) {
        if (i % imageSize === 0 && i > 0) {
          text += '\n';
        }
        const numString = imageVector[i].toString();
        text += ' '.repeat(numString.length < 4 ? 4 - numString.length : 0) + numString;
      }
      return text;
    }

    // Convert a text representation of an MNIST image into an deeplearn Tensor4D
    // of shape [1, imageSize, imageSize, 1].
    //
    // Args:
    //   text: A String representing the MNIST image.
    //
    // Returns:
    //   A Tensor4D instance representing the image, in a size-1 batch.
    //     Shape: [1, imageSize, imageSize, 1].
    function textToImageArray(text) {
      // Split into rows.
      const pixels = [];
      const rows = text.split('\n');
      for (const row of rows) {
        const tokens = row.split(' ');
        for (const token of tokens) {
          if (token.length > 0) {
            pixels.push(Number.parseInt(token) / 255);
          }
        }
      }
      if (pixels.length !== imageSize * imageSize) {
        throw new Error('Incorrect length of image vector (expected ' +
                        imageSize * imageSize + '; got ' +
                        pixels.length + ')');
      }
      return tfjs_layers.dl.tensor4d(pixels, [1, imageSize, imageSize, 1]);
    }

    // Perform prediction on the input image using the loaded model.
    function predict() {
      let batchInput = null;
      try {
        batchInput = textToImageArray(imageInput.val());
      } catch (e) {
        $('#predict-header').empty();
        const errorTd = $('<td>Error:&nbsp;' + e.message + '</td>');
        $('#predict-header').append(errorTd);
        $('#predict-values').empty();
      }

      tfjs_layers.dl.tidy(() => {
        const predictOut = Array.from(model.predict(batchInput).dataSync());
        const winner = _.indexOf(predictOut, _.max(predictOut));

        $('#predict-header').empty();
        for (let i = 0; i < 5; ++i) {
          const titleTd = $('<td>' + String(i + 5) + '</td>')
          $('#predict-header').append(titleTd);
        }
        $('#predict-values').empty();
        for (const predictVal of predictOut) {
          const valTd = $('<td>' + predictVal.toFixed(6) + '</td>');
          $('#predict-values').append(valTd);
        }
        $('#winner').val(winner + 5);
      });
    }

    imageInput.keyup(() => {
      predict();
    });

    testImageSelect.change(() => {
      imageInput.val(imageVectorToText(testExamples[testImageSelect.val()]));
      predict();
    });

    imageInput.val(imageVectorToText(testExamples['5_1']));

    // Convert an MNIST dataset to two deeplearn.js Tensors.
    const numClasses = 5;
    function indexToOneHot(index, numClasses) {
      const oneHot = [];
      for (let i = 0; i < numClasses; ++i) {
        oneHot.push(i === index ? 1 : 0);
      }
      return oneHot;
    }
    function convertDataToTensors(data) {
      const numExamples = data.length;
      const imgRows = data[0].x.length;
      const imgCols = data[0].x[0].length;
      const xs = [];
      const ys = [];
      data.map(example => {
        xs.push(example.x);
        ys.push(indexToOneHot(example.y, numClasses));
      });
      let xsTensor = tfjs_layers.backend.reshape(
          tfjs_layers.dl.tensor3d(xs, [numExamples, imgRows, imgCols]),
          [numExamples, imgRows, imgCols, 1]);
      xsTensor = tfjs_layers.backend.scalarTimesArray(
          tfjs_layers.dl.scalar(1 / 255), xsTensor);
      let ysTensor = tfjs_layers.dl.tensor2d(ys, [numExamples, numClasses]);
      return [xsTensor, ysTensor];
    }

    const trainProg = $('#trainProg');

    console.log('Converting gte5 data to tensors.');
    const gte5TrainXsAndYs = convertDataToTensors(gte5TrainData);
    const gte5TrainXs = gte5TrainXsAndYs[0];
    const gte5TrainYs = gte5TrainXsAndYs[1];
    const gte5TestXsAndYs = convertDataToTensors(gte5TestData);
    const gte5TestXs = gte5TestXsAndYs[0];
    const gte5TestYs = gte5TestXsAndYs[1];

    // Perform retraining on the loaded model.
    async function retrainModel() {
      // Check that the layer types are correct.
      console.assert(model.layers[0].constructor.name === 'Conv2D');
      console.assert(model.layers[1].constructor.name === 'Activation');
      console.assert(model.layers[2].constructor.name === 'Conv2D');
      console.assert(model.layers[3].constructor.name === 'Activation');
      console.assert(model.layers[4].constructor.name === 'MaxPooling2D');
      console.assert(model.layers[5].constructor.name === 'Dropout');
      console.assert(model.layers[6].constructor.name === 'Flatten');

      console.log('Freezing feature layers of the model.');
      for (let i = 0; i < 7; ++i) {
        model.layers[i].trainable = false;
      }
      model.compile({
          loss: 'categoricalCrossentropy',
          optimizer: 'Adam',
          metrics: ['acc'],
      });

      // Verify that the trainable weights are correct after the freezing.
      console.assert(model.trainableWeights.length === 4);
      console.assert(_.isEqual(model.trainableWeights[0].shape, [4608, 128]));
      console.assert(_.isEqual(model.trainableWeights[1].shape, [128]));
      console.assert(_.isEqual(model.trainableWeights[2].shape, [128, 5]));
      console.assert(_.isEqual(model.trainableWeights[3].shape, [5]));

      const batchSize = 128;
      const epochs = Number.parseInt($("#epochs").val())

      // Custom callback for updating the progress bar at the end of epochs.
      const customCallbackConfig = {
          onTrainBegin: async (logs) => {
            $('#retrainStatus').text(
                'Please wait and do NOT click anything while the model ' +
                'retrains...');
            $('#retrainStatus').css('color', 'blue');
            trainProg.val(0);
            await tfjs_layers.dl.nextFrame();
          },
          onTrainEnd: async (logs) => {
            $('#retrainStatus').text(
                'Done retraining ' + epochs + ' epochs. Standing by.');
            $('#retrainStatus').css('color', 'black');
            await tfjs_layers.dl.nextFrame();
          },
          onEpochEnd: async (epoch, logs) => {
            $('#retrainStatus').text(
                'Please wait and do NOT click anything while the model ' +
                'retrains... (Epoch ' + (epoch + 1) + ' of ' +  epochs + ')');
            trainProg.val((epoch + 1) / epochs * 100);
            await tfjs_layers.dl.nextFrame();
          },
      };

      console.log('Retraining model.');
      const beginMs = performance.now();
      const history = await model.fit({
          x: gte5TrainXs,
          y: gte5TrainYs,
          batchSize: batchSize,
          epochs: epochs,
          // TODO(cais): visualize validation results in frontend during
          //   training. See b/73735367.
          // validationData: [gte5TestXs, gte5TestYs],
          callbacks: customCallbackConfig,
      });
      console.log(history.history);
      console.log('DONE retraining model: elapsed time = ' +
                  (performance.now() - beginMs).toFixed(1) + ' ms');
    }

    $('#retrain').click(retrainModel);
  </script>
</body>
